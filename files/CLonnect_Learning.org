#+title: Connector-Service (SBCL) — Learning Plan & Todos (Windows Service via CFFI, JSON-first)
#+author: Anna + Du
#+options: toc:3 num:nil
#+startup: overview

* Projekt-Zusammenfassung
- Ziel: Self-hosted Integration-/Connector-Service in Common Lisp (SBCL), der Shopify <-> Firebird (LAN, Firebird 2.5–5) bidirektional synchronisieren kann.
- Fokus: Sysadmin-trivial Setup ohne Docker; Windows Server ist Prio 1, Ubuntu bleibt Zielplattform.
- Betrieb: Multi-tenant pro Instanz.
- MVP Constraints:
  - filebased state (keine DB Pflicht)
  - Secrets nicht in Templates; sichere Ablage über Files + Permissions
  - TLS idealerweise via Reverse Proxy (extern), Service intern nur loopback HTTP
- UX: Nicht-Lisper sollen Specs/Templates über JSON (v1) pflegen; intern AST/S-Expr, strict validate -> compile -> execute.
- Wichtig: Kein NSSM/Wrapper. Windows Service muss “native” umgesetzt werden.

* Aktueller Stand / Entscheidungen (fix)
- [X] Lisp Implementation: SBCL
- [X] Spec-Format v1: JSON-first
- [X] Windows Service: ohne NSSM/Wrapper
- [X] CFFI ist erlaubt und gewünscht (Lernziel)
- [X] Logging v1: file logging reicht
- [X] Datenobjekte für MVP: Orders, Products, Customers

* Verifizierte Bausteine (nur was wir wirklich belegen konnten)
** FFI Basis
- CFFI (portable FFI, SBCL kompatibel)
- Quelle: https://github.com/cffi/cffi

** Crypto (Shopify Webhooks / HMAC-SHA256)
- ironclad
- Quelle: https://github.com/sharplispers/ironclad

** Firebird ODBC Treiber (offiziell)
- FirebirdSQL firebird-odbc-driver
- Quelle: https://github.com/FirebirdSQL/firebird-odbc-driver

** HTTP Client Kandidat (Shopify)
- Drakma (etabliert; für Dexador müssen wir Repo/Activity noch gezielt verifizieren)
- Quelle: https://edicl.github.io/drakma/

* Architektur-Prinzipien (MVP)
** Process/Runtime Modell
- Ein Daemon/Service, der dauerhaft läuft und Sync-Jobs ausführt.
- Ein CLI Tool für:
  - init / validate / preview / deploy (MVP)
- Daemon läuft in zwei Modi:
  - Console-Mode (Dev/Debug)
  - Service-Mode (Windows SCM) — gleicher Binary, anderer Startpfad

** Multi-tenant Modell (v1)
- Eine Instanz hostet mehrere Tenants/Integrationen.
- Config und State werden pro Tenant und Integration segmentiert.

** TLS
- MVP: TLS wird extern terminiert (IIS/Reverse Proxy).
- Daemon bindet standardmäßig an loopback.
- Vorteil: Zertifikate/Reload/Hardening werden ops-seitig gelöst.

** State & Secrets
- State: filebased, atomare Writes + Locking (wichtig für Multi-tenant).
- Secrets: separate Dateien, strikte Rechte; niemals in Templates/Examples.

* Plattform-Policies (MVP Defaults)
** Windows (Prio 1)
- Base dir: %ProgramData%\<product>\
  - config\config.json
  - config\secrets.d\
  - state\
  - logs\
- Working directory darf NICHT vorausgesetzt werden (Services starten oft in System32).

** Ubuntu (später gleichziehen)
- /etc/<product>/config.json
- /etc/<product>/secrets.d/
- /var/lib/<product>/state/
- Logging: journald oder /var/log/<product>/ (v1 kann stdout + optional file)

* Roadmap / Milestones (Windows-first)
** M0 — Foundations / Skeleton (kein Business-Connector)
Ziele:
- Repo-Struktur + Module
- CLI skeleton
- Daemon skeleton (console + service)
- health endpoint
- file logging
- Windows Ops Doc (install/run/stop)

Deliverables:
- <product> (CLI)
- <productd> (Daemon)
- docs/operations-windows.md
- docs/architecture.md (1 Seite)

** M1 — Spec v1 + Validator
- JSON Spec -> parse -> AST -> validate (strict)
- Fehlerformat:
  - severity: error/warn
  - path (json pointer oder dotted path)
  - message + hint + doc link

** M2 — Preview Engine + Fixtures (CSV/JSON)
- Preview deterministisch
- Golden tests (fixtures -> expected output)
- CSV: heuristische Typ-Inferenz mit klaren Regeln + warnings

** M3 — Deploy + filebased state
- deploy workflow (copy config, restart service)
- state layout (tenant/integration)
- locking + migrations v1

** M4 — Shopify minimal connector
- Orders/Products/Customers minimal flows
- Webhooks später (HMAC via ironclad)

** M5 — Firebird connector + optional introspection
- ODBC-first evaluieren (weil Windows + Firebird 2.5–5)
- Kompatibilitätsmatrix erstellen + testen

** M6 — Templates/Docs/Release Packaging
- community templates + docs
- Windows installer story verbessern (optional)
- Ubuntu packaging (.deb) (optional)

* Learning Todos (dein Lernpfad)
** L0 — Projekt-Setup & Orientierung (1–2h)
- [ ] Produktname festlegen (<product>, <productd>) + Windows Service Name
- [ ] Repo-Struktur anlegen (cli/daemon/core/platform/windows-service/spec/tests/docs/packaging)
- [ ] docs/architecture.md: Überblick (CLI vs daemon, multi-tenant, config/state, preview flow)
DoD:
- Ein neuer Entwickler versteht in 5 Minuten: “was läuft wo” und “wo liegen config/state/logs”.

** L1 — CFFI Basics (2–4h)
Ziel: Du verstehst das Prinzip FFI so, dass Windows Service API realistisch wird.
- [ ] Foreign library laden und eine WinAPI-Funktion minimal aufrufen (Proof)
- [ ] Dokumentiere String-Encoding Strategie (UTF-16 vs UTF-8) für Windows APIs
- [ ] Dokumentiere Fehlerbehandlung: Rückgabewerte + GetLastError (Konzept)
DoD:
- Ein kleines FFI-Proof ist dokumentiert (README oder doc page) und reproduzierbar.

** L2 — Windows Service Lifecycle (4–10h, iterativ)
Ziel: Daemon kann ohne NSSM “echter” Windows Service sein.
- [ ] Verstehen: SCM ruft ServiceMain auf; ControlHandler empfängt STOP/SHUTDOWN.
- [ ] Design: Status-Transitions festlegen (START_PENDING, RUNNING, STOP_PENDING, STOPPED).
- [ ] Daemon run-loop stoppbar machen (stop flag / cancellation token Konzept).
- [ ] Install/Run/Stop Dokumentation via sc.exe / PowerShell (ohne Dritttools).
DoD:
- Service kann installiert, gestartet und gestoppt werden.
- Stop beendet sauber (keine Korruption, keine hängenden Threads).
- Logfile enthält Start/Stop + Grundinfos.

** L3 — File Logging (1–3h)
Ziel: Logs sind im Service-Betrieb nutzbar und “ops-tauglich”.
- [ ] Logformat festlegen (timestamp, level, tenant, integration-id, msg)
- [ ] Rotation/Retention minimal planen (z.B. size-based oder daily)
- [ ] Logpfad policy Windows (ProgramData\...\logs)
DoD:
- Admin findet Logs sofort; Logs wachsen nicht unendlich.

** L4 — JSON-first Spec v1 (4–8h)
Ziel: Nicht-Lisper können Spec editieren und verstehen.
- [ ] Minimal Spec definieren:
  - tenants[]
  - integrations[] (id, tenant-id)
  - connectors: shopify/firebird placeholders (auth/host etc. noch minimal)
  - entities: customer/product/order (nur MVP fields)
  - mappings: source->canonical & canonical->target (noch ohne komplexe transforms)
- [ ] Validator-UX: Fehlermeldungen mit Pfad + hint
- [ ] “trusted mode” explizit aus (keine Code-Ausführung aus Spec)
DoD:
- validate erkennt zentrale Fehler (missing fields, types) und ist verständlich.

** L5 — Preview Engine & Golden Tests (4–10h)
Ziel: Deterministische Vorschau für Mapping-Entwicklung.
- [ ] Preview output format festlegen (z.B. canonical records + planned actions)
- [ ] Fixtures definieren:
  - CSV fixtures als record source
  - JSON fixtures als expected output
- [ ] Determinismus-Checkliste erstellen (sort order, stable serialization, no timestamps)
DoD:
- Golden tests laufen stabil und reproduzierbar.

** L6 — Multi-tenant filebased State Design (4–10h)
Ziel: Robust trotz paralleler runs.
- [ ] State directory layout:
  - state/tenants/<tenant-id>/integrations/<integration-id>/...
- [ ] Locking Konzept (pro integration-run)
- [ ] State schema versioning (state-version file) + migrations v1
DoD:
- Zwei Tenants können parallel existieren, ohne State-Kollisionen.
- Crash während Write beschädigt State nicht (atomare Writes Konzept).

** L7 — Shopify Connector Grundlagen (1–2 Tage, research-first)
Ziel: Saubere, belegte API-Details + minimal flows.
- [ ] Research: Auth, pagination, rate limits, webhook verification (mit Quellen sammeln)
- [ ] Minimalfelder definieren für customer/product/order
- [ ] MVP Sync Flows definieren:
  - Shopify -> Canonical (pull)
  - Canonical -> Shopify (push)
DoD:
- docs/shopify-connector.md enthält belegte Limits/Flows + minimal mapping plan.

** L8 — Firebird Connectivity Plan (1–3 Tage)
Ziel: Firebird 2.5–5 realistisch anbinden.
- [ ] Research: Firebird ODBC Treiber + Client Kompatibilität (2.5–5)
- [ ] Research: Common Lisp ODBC Bindings für SBCL (mit Quellen, Activity)
- [ ] PoC Plan: “kleinstes Query/Resultset” über ODBC
DoD:
- Entscheidungsvorlage: “So machen wir Firebird v1” + Testplan + Known Limitations.

* Offene Entscheidungen (müssen bald beantwortet werden)
- [ ] Produktname + Service Name
- [ ] Reverse Proxy Standard auf Windows: IIS vs “bring your own”
- [ ] ODBC in SBCL: welche Library/Approach ist praktikabel (nach Recherche)
- [ ] Deploy UX: deploy auf dem Server (CLI) vs remote deploy (später)

* Next Actions (nächste 1–2 Stunden) — konkret
- [ ] Produktname und Windows Service Name festlegen
- [ ] Windows Path Policy als Doc schreiben (ProgramData Layout, Rechte/ACL grob)
- [ ] ops-windows Doc: sc.exe install/start/stop Skeleton (Platzhalter ok)
- [ ] Logging policy v1 festlegen (Format + Rotation minimal)
- [ ] Milestone M0 Scope “hart” definieren: was muss wirklich laufen?

* Notizen / Links
- CFFI: https://github.com/cffi/cffi
- ironclad: https://github.com/sharplispers/ironclad
- Firebird ODBC driver: https://github.com/FirebirdSQL/firebird-odbc-driver
- Drakma: https://edicl.github.io/drakma/
